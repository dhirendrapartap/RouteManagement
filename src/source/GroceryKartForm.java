
package source;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import java.io.*;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ButtonGroup;
import javax.swing.JFileChooser;
import javax.swing.JProgressBar;
import javax.swing.SwingUtilities;


public class GroceryKartForm extends javax.swing.JFrame {

    public static int p = 0;
    public static int g = 0;
    public static double c = 0;
    public static double m = 0;
    public static double s = 0;
    public static int n = 0;
    public static File file;
    public static File file1;
    public static boolean flag=false;
    public static boolean flag1=false;
    public static int val=0;

    /**
     * Creates new form NewJFrame
     */
    private void groupButton(){
        ButtonGroup bg = new ButtonGroup();
        bg.add(jRadioButton1);
        bg.add(jRadioButton2);
    }
    public GroceryKartForm() {
        initComponents();
        groupButton();
    }
  
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileChooser = new javax.swing.JFileChooser();
        buttonGroup1 = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        text = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        text1 = new javax.swing.JTextField();
        text2 = new javax.swing.JTextField();
        text3 = new javax.swing.JTextField();
        text5 = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        text4 = new javax.swing.JTextField();
        demand = new javax.swing.JButton();
        distance = new javax.swing.JButton();
        textdemand = new javax.swing.JTextField();
        textdistance = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        jRadioButton1 = new javax.swing.JRadioButton();
        jRadioButton2 = new javax.swing.JRadioButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Input"));
        jPanel1.setName(""); // NOI18N

        jLabel1.setText("Population size           :");

        text.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textActionPerformed(evt);
            }
        });

        jLabel2.setText("Generations                :");

        jLabel3.setText("Crossover probability :");

        jLabel4.setText("Mutation probability    :");

        jLabel5.setText("How many solutions you want to see?");

        text1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                text1ActionPerformed(evt);
            }
        });

        jLabel6.setText("Selection percent        :");

        demand.setText("Select demand table");
        demand.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                demandActionPerformed(evt);
            }
        });

        distance.setText("Select distance matrix");
        distance.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                distanceActionPerformed(evt);
            }
        });

        jButton1.setText("Submit");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel8.setText("Select the Crossover you want to use :");

        jRadioButton1.setText("BCRC");
        jRadioButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton1ActionPerformed(evt);
            }
        });

        jRadioButton2.setText("PMX");
        jRadioButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel2)
                                    .addComponent(jLabel1)
                                    .addComponent(jLabel4))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(text3)
                                    .addComponent(text1)
                                    .addComponent(text)
                                    .addComponent(text2, javax.swing.GroupLayout.DEFAULT_SIZE, 78, Short.MAX_VALUE)))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(text4)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(distance, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(textdemand)
                            .addComponent(demand, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(textdistance))
                        .addGap(15, 15, 15))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel8)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jRadioButton1)
                                .addGap(101, 101, 101)
                                .addComponent(jRadioButton2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 134, Short.MAX_VALUE)
                                .addComponent(jButton1)))
                        .addContainerGap())
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(text5, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(14, 14, 14)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel2)
                            .addComponent(text1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(text, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(12, 12, 12)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(text2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(text3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(text4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(8, 8, 8)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jRadioButton2)
                    .addComponent(jRadioButton1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(text5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(39, Short.MAX_VALUE))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(demand)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(textdemand, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addComponent(distance)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(textdistance, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton1)
                .addGap(20, 20, 20))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Output"));

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 355, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(63, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabel7.setForeground(new java.awt.Color(255, 0, 0));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(45, 45, 45)
                .addComponent(jLabel7)
                .addContainerGap(415, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 32, Short.MAX_VALUE)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void textActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_textActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        if (text.getText().isEmpty() || text1.getText().isEmpty() || text2.getText().isEmpty() || text3.getText().isEmpty() || text4.getText().isEmpty() || text5.getText().isEmpty() || textdemand.getText().isEmpty() || textdistance.getText().isEmpty()) {
            jLabel7.setText("ERROR: Please enter all the required details");
        }
        p = Integer.parseInt(text.getText());
        g = Integer.parseInt(text1.getText());
        c = Double.parseDouble(text2.getText());
        m = Double.parseDouble(text3.getText());
        s = Double.parseDouble(text4.getText());
        n = Integer.parseInt(text5.getText());
        flag=jRadioButton1.isSelected();
        flag1=jRadioButton2.isSelected();
        //GroceryKart.proceed();
        GroceryKart gr = new GroceryKart();
        gr.proceed(gr);
        //int progressValue = 100/gr.generations;
       // System.out.println(progressValue);
        for (int i = 0; i < gr.generations; i++) {
            gr.runAlgorithm(gr,i);
            //System.out.println((i+1)*progressValue);
        }
        
        String display = gr.saveAndDisplay(gr);
        
        
        jTextArea1.setText(display);
        
    }//GEN-LAST:event_jButton1ActionPerformed

    private void text1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_text1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_text1ActionPerformed

    private void demandActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_demandActionPerformed
        // TODO add your handling code here:
        int returnVal = fileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            file = fileChooser.getSelectedFile();
            textdemand.setText(file.getAbsolutePath());
    }//GEN-LAST:event_demandActionPerformed
    }
        private void distanceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_distanceActionPerformed
            // TODO add your handling code here:
            int returnVal1 = fileChooser.showOpenDialog(this);
            if (returnVal1 == JFileChooser.APPROVE_OPTION) {
                file1 = fileChooser.getSelectedFile();
                textdistance.setText(file1.getAbsolutePath());
        }//GEN-LAST:event_distanceActionPerformed
        }
    private void jRadioButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jRadioButton1ActionPerformed

    private void jRadioButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jRadioButton2ActionPerformed
    
    /**
     * @param args the command line arguments
     */
    public static void main() {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GroceryKartForm().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton demand;
    private javax.swing.JButton distance;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JRadioButton jRadioButton1;
    private javax.swing.JRadioButton jRadioButton2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField text;
    private javax.swing.JTextField text1;
    private javax.swing.JTextField text2;
    private javax.swing.JTextField text3;
    private javax.swing.JTextField text4;
    private javax.swing.JTextField text5;
    private javax.swing.JTextField textdemand;
    private javax.swing.JTextField textdistance;
    // End of variables declaration//GEN-END:variables
}
/*
 * a temporary class needed during pareto Ranking for storing multiple candidates
 * It contains an arraylist of candidates at a given rank.
 */

class RankedChromosome {

    ArrayList<Candidate> rank;
}

class GroceryKart {

    int trucksRequired;
    int maxStops;
    static boolean flag;
    static boolean flag1;
    static int n = GroceryKartForm.n;
    static File f = GroceryKartForm.file;
    static File f1 = GroceryKartForm.file1;
    static int val = GroceryKartForm.val;
    int maxStores;
    int maxDemand;
    String routingMap;
    double distanceTravelled;
    double maxDistanceTravelled;
    double costIncurred;
    double efficiency;
    double profit;
    int deliveryTime;
    int maxTime;
    int userId;
    String password;
    int generations;
    int populationSize;
    static double mutationProbability = GroceryKartForm.m;
    static double crossoverProbability = GroceryKartForm.c;
    static double selectionPercent = GroceryKartForm.s;
    ArrayList<Candidate> currentCandidates;
    ArrayList<Candidate> nextCandidates;
    ArrayList<Candidate> matingPool;
    ArrayList<Store> stores; // list of stores containing their names as string.
    double DCStoreMatrix[][]; // distance matrix including warehouse to store distance as last row.
    int storeSize; // number of stores including Data centre or Warehouse.
    ArrayList<RankedChromosome> rankArray; // ranked chromosomes are kept in this arraylist
    int SELECTIONSIZE;

    /*
     * Constructor to initialize all the arraylists
     */
    public GroceryKart() {
        currentCandidates = new ArrayList<Candidate>();
        nextCandidates = new ArrayList<Candidate>();

        stores = new ArrayList<Store>();
        generations = GroceryKartForm.g;
        flag=GroceryKartForm.flag;
        flag1=GroceryKartForm.flag1;

    }

    public void proceed(GroceryKart g) {
        

        ReadData r = new ReadData(g);
        g.populationSize = GroceryKartForm.p;
        g.SELECTIONSIZE = (int) (selectionPercent * g.populationSize);
        System.out.println("selection size: " + g.SELECTIONSIZE);
        //r.readDemandTable(); // this method must be called first to read stores.
        //r.readDistanceMatrix(); // this method must be called second (dependent on stores).
        try {
            FileReader fr = new FileReader(f.getAbsolutePath()); // this method must be called first to read stores.
            r.readDemandTable(fr);
        } catch (IOException ex) {
            System.out.println("problem accessing file" + f.getAbsolutePath());
        }
        try {
            FileReader fr1 = new FileReader(f1.getAbsolutePath());// this method must be called second (dependent on stores).
            r.readDistanceMatrix(fr1);
        } catch (IOException ex) {
            System.out.println("problem accessing file" + f1.getAbsolutePath());
        }

        //r.displayDemandTable();
        //System.out.println("");
        //r.displayDistanceMatrix();
        //System.out.println("");

        //g.generatePopulation();
        g.greedyGeneratePopulation(100.0);
        //System.out.println("Current Candidates Population: ");
        //g.displayPopulation(g.currentCandidates);
        System.out.println("");
//        for (int i = 0; i < g.currentCandidates.size(); i++) {
//            System.out.println("Chromosome: " + i);
//            Candidate test = g.currentCandidates.get(i);
//            System.out.println("Fitness : " + test.fitness);
//            System.out.println("Number of Routes: " + test.routeTable.size());
//            //g.displayRoutes(test.routeTable);
//        }

        //System.out.println("");
        
           }
    
    public void runAlgorithm(GroceryKart g,int i) {
        
//            g.tournamentSelection();
            g.paretoRanking();

            g.tournamentRankSelection();

            //System.out.println(g.checkStoresAll(g.currentCandidates.get(0).routeTable));
            if(flag1)
            g.crossoverPMX();
            if(flag)
            g.crossover();
            g.mutation(g.nextCandidates);

            g.currentCandidates = g.nextCandidates;
            //System.out.println("current candidate size: " + g.currentCandidates.size());
            System.out.println("Generation: " + (i + 1));
             
    }
    
    public String saveAndDisplay(GroceryKart g) {
        String s = ""; 
        Collections.sort(g.currentCandidates);

        //System.out.println("Mating Pool Population: ");
        //g.displayPopulation(g.matingPool);
        System.out.println("");
        for (int i = 1; i <= n; i++) {
            Candidate test = g.currentCandidates.get(i);
            s = s + "Candidate: " + i + "\nDistance travelled by trucks:" + test.fitness + "\nNumber of Trucks: " + test.routeTable.size() + "\nRank: " + test.rank + "\n";
        }
        g.writeToFile();

        
        return s;

    }
    /*
     * This method generates candidates randomly.
     * A permutation of 600 integer from 1 to 600 is shuffled every time.
     * Each generated candidate is stored in currentCandidates after
     * evaluating the fitness and routes
     */
    public void generatePopulation() {
        for (int i = 0; i < populationSize; i++) {
            ArrayList<Integer> tmp = new ArrayList<Integer>();
            tmp.add(0);
            for (int j = 1; j < storeSize; j++) {
                tmp.add(j);
            }
            Random r = new Random();
            Candidate temp = new Candidate();
            int tmpncustomers = storeSize;

            temp.chromosome.add(tmp.get(0));
            tmp.remove(0);
            tmpncustomers--;

            for (int j = 1; j < storeSize; j++) {
                int tmpindex = r.nextInt(tmpncustomers);
                int tmpadd = tmp.get(tmpindex);
                tmp.remove(tmpindex);
                temp.chromosome.add(tmpadd);
                tmpncustomers--;
            }
            temp.routeTable = generateRoutes(temp);

            temp.fitness = evaluateFitnessCandidate(temp);
            currentCandidates.add(temp);
        }
    }

    /*
     * The method is called in generatePopulation and greedyGeneratePopulation etc.
     * It generates routes in a given candidate of 600 nodes by statisfying the
     * conditions we imposed on a given truck
     * 1. maxDemand
     * 2. maxStops
     * 3. maxDistanceTravelled
     */
    private ArrayList<Route> generateRoutes(Candidate tmp) {
        ArrayList<Route> alroutesParent = new ArrayList<Route>();
        Route temp = new Route();
        temp.route.add(tmp.chromosome.get(0));
        int currentStops = 0;
        double currentDemand = 0;
        double currentDistance = 0;
        int length = tmp.chromosome.size();
        for (int i = 1; i < length; i++) {
            currentStops += 1;
            currentDemand += stores.get(tmp.chromosome.get(i)).demand;
            currentDistance += DCStoreMatrix[tmp.chromosome.get(i - 1)][tmp.chromosome.get(i)];
            if (currentDemand <= maxDemand && currentStops <= maxStops && currentDistance <= maxDistanceTravelled / 2) {
                temp.route.add(tmp.chromosome.get(i));
            } else {
                currentDemand = 0;
                currentStops = 0;
                currentDistance = 0;
                alroutesParent.add(temp);
                temp = new Route();
                temp.route.add(tmp.chromosome.get(0));
            }
        }
        alroutesParent.add(temp);

        return alroutesParent;
    }

    // review greedy method , continous answer nodes are coming
    // it works reviewed and so much good candidates are coming really superb!!
    /*
     * The method selects the node in a given euclidRadius.
     * Based on greedy strategy it takes the nearest node in a given euclidRadius
     * It then keeps on adding the nearest neighbours, finally appending the last
     * 600th node completing a candidate, generating routes and evaluating fitness
     * It gets added to currentCandidates
     */
    public void greedyGeneratePopulation(double euclidRadius) {
        for (int i = 0; i < populationSize; i++) {
            Candidate temp = new Candidate();

            ArrayList<Integer> tmp = new ArrayList<Integer>();
            tmp.add(0);
            for (int j = 1; j < storeSize; j++) {
                tmp.add(j);
            }

            temp.chromosome.add(0);
            tmp.remove(0);

            Random r = new Random();
            int rcustomer = r.nextInt(storeSize - 2) + 1;
            int custVal = tmp.get(rcustomer);
            tmp.remove(rcustomer);
            temp.chromosome.add(custVal);

            int tmpncustomers = storeSize;
            for (int j = 2; j < storeSize; j++) {
                // check the nearest neighbour to rcustomer in euclid radius specified
                int minindex = -1;
                double mindist = Double.MAX_VALUE;
                for (int k = 0; k < tmpncustomers - 2; k++) {
                    int l = tmp.get(k);
                    if (DCStoreMatrix[rcustomer][l] != 0 && DCStoreMatrix[rcustomer][l] < mindist && DCStoreMatrix[rcustomer][l] < euclidRadius) {
                        mindist = DCStoreMatrix[rcustomer][j];
                        minindex = k;
                    }
                }
                if (minindex != -1) {
                    custVal = tmp.get(minindex);
                    tmp.remove(minindex);
                    temp.chromosome.add(custVal);
                    rcustomer = minindex;
                } else {
                    rcustomer = r.nextInt(tmpncustomers);
                    custVal = tmp.get(rcustomer);
                    tmp.remove(rcustomer);
                    temp.chromosome.add(custVal);
                }
                tmpncustomers--;
            }
            temp.routeTable = generateRoutes(temp);
            temp.fitness = evaluateFitnessCandidate(temp);
            currentCandidates.add(temp);
        }
    }

    /*
     * We have used weighted fitness function
     * fitness = alpha*trucks + beta*distanceTravelled
     */
    private double evaluateFitnessCandidate(Candidate tmp) {
        double tmpfitness = 0;
        int nroutes = tmp.routeTable.size();
//        for (int i = 1; i < storeSize; i++) {
//            int p = tmp.chromosome.get(i - 1);
//            int q = tmp.chromosome.get(i);
//            if (DCStoreMatrix[p][q] != 0) {
//                tmpfitness += DCStoreMatrix[p][q];
//            }
//        }

        for (Route tmpRoute : tmp.routeTable) {
            evaluateFitnessRoute(tmpRoute);
            tmpfitness += tmpRoute.routeFitness;
        }
//
//        double alpha = 100;
//        double beta = 0.001;
//        tmpfitness = alpha * nroutes + beta * tmpfitness;

        return tmpfitness;
    }

    private void evaluateFitnessRoute(Route tmp) {
        double tmpfitness = 0;
        for (int i = 1; i < tmp.route.size(); i++) {
            int p = tmp.route.get(i - 1);
            int q = tmp.route.get(i);
            if (DCStoreMatrix[p][q] != 0) {
                tmpfitness += DCStoreMatrix[p][q];
            }
        }
        tmp.routeFitness = tmpfitness;
    }

    private void displayPopulation(ArrayList<Candidate> population) {
        for (Candidate tmp : population) {
            System.out.println(tmp.toString());
        }
    }

    private void displayRoutes(ArrayList<Route> alroutesParent) {
        // display routes
        for (Route tmp : alroutesParent) {
            for (int i : tmp.route) {
                System.out.print(i + " ");
            }
            System.out.println("");
        }
    }

    /*
     * Selecting from currentCandidates based on fitness value assigned
     * We have used the tournament selection
     */
    public void tournamentSelection() {
        matingPool = new ArrayList<Candidate>();
        ArrayList<Integer> populationSet = new ArrayList<Integer>();
        for (int i = 0; i < populationSize; i++) {
            populationSet.add(i);
        }

        int tmpncustomers = populationSize;
        for (int k = 0; k < SELECTIONSIZE; k++) {
            ArrayList<Integer> tournamentSet = new ArrayList<Integer>();
            ArrayList<Double> fitnessTournamentSet = new ArrayList<Double>();

            for (int i = 0; i < 4; i++) {
                Random r = new Random();
                int index = r.nextInt(tmpncustomers);
                int tmpnum = populationSet.get(index);
                populationSet.remove(index);
                tournamentSet.add(tmpnum);
                fitnessTournamentSet.add(currentCandidates.get(index).fitness);
                tmpncustomers--;
            }

            Random r = new Random();
            double gutter = r.nextDouble();

            if (gutter < 0.8) {
                double minFit = Double.MAX_VALUE;
                int minindex = -1;
                for (int i = 0; i < 4; i++) {
                    if (fitnessTournamentSet.get(i) < minFit) {
                        minFit = fitnessTournamentSet.get(i);
                        minindex = i;
                    }
                }
                Candidate tmp = currentCandidates.get(tournamentSet.get(minindex));
                matingPool.add(tmp);
                tournamentSet.remove(minindex);
            } else {
                int index = r.nextInt(4);
                Candidate tmp = currentCandidates.get(tournamentSet.get(index));
                matingPool.add(tmp);
                tournamentSet.remove(index);
            }

            populationSet.addAll(tournamentSet);
            tmpncustomers += 3;
        }
    }

    /*
     * When paretoRanking is used, the selection procedure is
     * Tournament Rank Selection as fitness is replaced by the rank
     * candidates get assigned during evaluation.
     * It uses an 80% selection of good candidates
     * and 20% selection of candidates randomly.
     */
    public void tournamentRankSelection() {
        matingPool = new ArrayList<Candidate>();
        for (RankedChromosome r : rankArray) {
            for (Candidate c : r.rank) {
                currentCandidates.add(c);
            }
        }
        ArrayList<Integer> populationSet = new ArrayList<Integer>();
        for (int i = 0; i < populationSize; i++) {
            populationSet.add(i);
        }

        int tmpncustomers = populationSize;
        for (int k = 0; k < SELECTIONSIZE / 2; k++) {
            ArrayList<Integer> tournamentSet = new ArrayList<Integer>();
            ArrayList<Integer> fitnessTournamentSet = new ArrayList<Integer>();

            for (int i = 0; i < 4; i++) {
                Random r = new Random();
                int index = r.nextInt(tmpncustomers);
                int tmpnum = populationSet.get(index);
                populationSet.remove(index);
                tournamentSet.add(tmpnum);
                fitnessTournamentSet.add(currentCandidates.get(index).rank);
                tmpncustomers--;
            }

            Random r = new Random();
            double gutter = r.nextDouble();

            if (gutter < 0.8) {
                double minFit = Double.MAX_VALUE;
                int minindex = -1;
                for (int i = 0; i < 4; i++) {
                    if (fitnessTournamentSet.get(i) < minFit) {
                        minFit = fitnessTournamentSet.get(i);
                        minindex = i;
                    }
                }
                Candidate tmp = currentCandidates.get(tournamentSet.get(minindex));
                matingPool.add(tmp);
                tournamentSet.remove(minindex);
            } else {
                int index = r.nextInt(4);
                Candidate tmp = currentCandidates.get(tournamentSet.get(index));
                matingPool.add(tmp);
                tournamentSet.remove(index);
            }

            populationSet.addAll(tournamentSet);
            tmpncustomers += 3;
        }
    }

    private Candidate inversion(Candidate candidate) {
        int chromosomeSize = candidate.chromosome.size();
        Random r = new Random();
        int windowSize = (r.nextDouble() > 0.5) ? 2 : 3;
        int pos = r.nextInt(chromosomeSize - 5) + 1;

        if (windowSize == 2) {
            int temp = candidate.chromosome.remove(pos);
            candidate.chromosome.add(pos, candidate.chromosome.remove(pos + 2));
            candidate.chromosome.add(pos + 2, temp);
        } else {
            int temp = candidate.chromosome.remove(pos);
            candidate.chromosome.add(pos, candidate.chromosome.remove(pos + 3));
            candidate.chromosome.add(pos + 3, temp);

            temp = candidate.chromosome.remove(pos + 1);
            candidate.chromosome.add(pos, candidate.chromosome.remove(pos + 2));
            candidate.chromosome.add(pos + 2, temp);
        }

        candidate.routeTable = generateRoutes(candidate);
        candidate.fitness = evaluateFitnessCandidate(candidate);

        return candidate;
    }

    /*
     * Mutation operater we used is inversion
     * The length of we decided to fix to 2 and 3.
     * Randomly get chosen and some part gets flipped.
     */
    private void mutation(ArrayList<Candidate> population) {
        Random r = new Random();
        int popSize = population.size();
        for (int i = 0; i < popSize; i++) {
            if (r.nextDouble() > GroceryKart.mutationProbability) {
                Candidate temp = inversion(population.remove(i));
                population.add(temp);
            }
        }
    }

    /*
     * Pareto Ranking based on non dominated solutions
     * gets assigned similar ranks and then next ones and so on...
     */
    public void paretoRanking() {
        rankArray = new ArrayList<RankedChromosome>();
        int currRank = 1;
        int N = populationSize;
        int m = populationSize;
        while (N != 0) {
            RankedChromosome temp = new RankedChromosome();
            temp.rank = new ArrayList<Candidate>();
            for (int i = 0; i < m; i++) {
                if (nonDominated(currentCandidates.get(i)) == true) {
                    currentCandidates.get(i).rank = currRank;
                }
            }
            for (int i = 0; i < m && i < N; i++) {
                if (currentCandidates.get(i).rank == currRank) {
                    temp.rank.add(currentCandidates.remove(i));
                    N--;
                    i--;
                }
            }
            rankArray.add(temp);
            currRank++;
            m = N;
        }
    }

    /*
     * procedure to find that a given candidate is non-dominated
     * in a given population
     */
    private boolean nonDominated(Candidate tmp) {
        for (Candidate temp : currentCandidates) {
            if (temp == tmp) {
                continue;
            }
            if ((temp.fitness <= tmp.fitness && temp.routeTable.size() < tmp.routeTable.size()) || (temp.fitness < tmp.fitness && temp.routeTable.size() <= tmp.routeTable.size())) {
                // tmp is dominated by temp
                return false;
            } else if (temp.fitness > tmp.fitness && temp.routeTable.size() > tmp.routeTable.size()) {
                // tmp is non-dominated
            } else {
                // not comparable
            }
        }
        return true;
    }

    /*
     * Best Cost Route Crossver (BCRC) Crossover
     * Presentation contains a slide to give the overview of
     * what method it uses to cross two candidates
     * and generate new good candidates using them.
     */
    private void bestRouteCrossover() {
        Random r = new Random();
        ArrayList<Integer> temp = new ArrayList<Integer>();
        int candidatesSize = matingPool.size();
        for (int i = 0; i < candidatesSize; i++) {
            temp.add(i);
        }

        int parent1Index = temp.remove(r.nextInt(candidatesSize));
        int parent2Index = temp.remove(r.nextInt(candidatesSize - 1));

        Candidate parent1 = matingPool.get(parent1Index);
        Candidate parent2 = matingPool.get(parent2Index);

        //ArrayList<Candidate> tmpCandidates = new ArrayList<Candidate>(); Return this data type

        // we have matingPool of candidates or population
        // each have its routing scheme stored in routes table
        // first we have to select randomly the key already written procedure
        // copy and paste here, tweak it to perform and adapt it to the terminology of this program
        // then create functions to check each route so that it satisfies the given constraints
        // after inserting the element in key selected for second parent into first parent
        // trying it for each route of first parent and calculating the feasibility
        // fitness score and then by comparing it with others inserting the given element
        // to its correct position. Also do this for other elements in the same key
        // Then select the element in key of first element and same procedure as applied above for second element
        // find best insertion point according to feasibility and fitness score.
        // add the new candidate to new population.

        // <!-- ========================================= -->

        Candidate copyParent1 = copyCandidate(parent1);
        Candidate copyParent2 = copyCandidate(parent2);

        // Selecting key for Parent 1
        int tmp = r.nextInt(copyParent1.routeTable.size());
        Route keyParent1 = new Route();
        for (int i : copyParent1.routeTable.get(tmp).route) {
            keyParent1.route.add(i);
        }
        // Selecting key for Parent 2
        tmp = r.nextInt(copyParent2.routeTable.size());
        Route keyParent2 = new Route();
        for (int i : copyParent2.routeTable.get(tmp).route) {
            keyParent2.route.add(i);
        }
//
//        System.out.println(keyParent1.route);
//        System.out.println(keyParent2.route);

        // call method for removing keyParent elements from alroutesParent
        ArrayList<Route> newalroutesParent2 = removeSelectedElements(keyParent1, copyParent2.routeTable);
        ArrayList<Route> newalroutesParent1 = removeSelectedElements(keyParent2, copyParent1.routeTable);

//        System.out.println("Modified route list of parents: ");
//        System.out.println("parent 1: ");
//        displayRoutes(newalroutesParent1);
//        System.out.println("parent 2: ");
//        displayRoutes(newalroutesParent2);

        // insert key for first parent in second new parent
//        System.out.println("Checking Insertion Validity: Start");
        for (int i : keyParent1.route) {
            if (i == 0) {
                continue;
            }
            boolean flag = false;
            ArrayList<Candidate> tmpCandidates = new ArrayList<Candidate>();
            for (int k = 0; k < newalroutesParent2.size(); k++) {
                //System.out.println("Route k: " + k);
                Route jroute = newalroutesParent2.get(k);
                for (int j = 1; j < jroute.route.size(); j++) {
                    // get a new copy of this candidate
                    Candidate tmpCopyCandidate = copyCandidate(copyParent2);
                    // insert the i node and check validity
                    tmpCopyCandidate.routeTable.get(k).route.add(j, i);
                    //System.out.println(checkInsertionValidity(tmpCopyCandidate.routeTable.get(k)));
                    if (checkInsertionValidity(tmpCopyCandidate.routeTable.get(k))) {
                        flag = true;
                        tmpCopyCandidate.fitness = evaluateFitnessCandidate(tmpCopyCandidate);
                        //System.out.println(tmpCopyCandidate.fitness);
                        tmpCandidates.add(tmpCopyCandidate);
                    }
                    // if not valid delete this candidate
                    // if valid calculate fitness
                    // store this candidate in new arraylist of new candidates
                }
            }
            Collections.sort(tmpCandidates);
            if (tmpCandidates.size() != 0) {
                copyParent2 = tmpCandidates.get(0);
            }
        }
//        System.out.println("All Numbers Present Before: " + checkStoresAll(parent2.routeTable));
//        System.out.println("Candidate Before Crossover: ");
//        displayRoutes(parent2.routeTable);
//        System.out.println(parent2.fitness);
//        System.out.println("All Numbers Present: " + checkStoresAll(copyParent2.routeTable));
//        System.out.println("New Candidate after Crossover: ");
//        displayRoutes(copyParent2.routeTable);
//        System.out.println(copyParent2.fitness);
//        System.out.println("Stop Insertion Validity");

        // select the best candidate from new arraylist of new candidates
        // replace the newalroutesParent2 with this one
        // do this with other parent also

        // insert key for second parent in first new parent
//        System.out.println("Checking Insertion Validity: Start");
        for (int i : keyParent2.route) {
            if (i == 0) {
                continue;
            }
            boolean flag = false;
            ArrayList<Candidate> tmpCandidates = new ArrayList<Candidate>();
            for (int k = 0; k < newalroutesParent1.size(); k++) {
                //System.out.println("Route k: " + k);
                Route jroute = newalroutesParent1.get(k);
                for (int j = 1; j < jroute.route.size(); j++) {
                    // get a new copy of this candidate
                    Candidate tmpCopyCandidate = copyCandidate(copyParent1);
                    // insert the i node and check validity
                    tmpCopyCandidate.routeTable.get(k).route.add(j, i);
                    //System.out.println(checkInsertionValidity(tmpCopyCandidate.routeTable.get(k)));
                    if (checkInsertionValidity(tmpCopyCandidate.routeTable.get(k))) {
                        flag = true;
                        tmpCopyCandidate.fitness = evaluateFitnessCandidate(tmpCopyCandidate);
                        //System.out.println(tmpCopyCandidate.fitness);
                        tmpCandidates.add(tmpCopyCandidate);
                    }
                    // if not valid delete this candidate
                    // if valid calculate fitness
                    // store this candidate in new arraylist of new candidates
                }
            }
            if (flag == false) {
                //System.out.println("Hello");
                copyParent1.routeTable.get(copyParent1.routeTable.size() - 1).route.add(i);
                copyParent1.fitness = evaluateFitnessCandidate(copyParent1);
                tmpCandidates.add(copyParent1);
            }
            Collections.sort(tmpCandidates);
            copyParent1 = tmpCandidates.get(0);
        }
//        System.out.println("All Numbers Present Before: " + checkStoresAll(parent1.routeTable));
//        System.out.println("Candidate Before Crossover: ");
//        displayRoutes(parent1.routeTable);
//        System.out.println(parent1.fitness);
//
//        System.out.println("All Numbers Present: " + checkStoresAll(copyParent1.routeTable));
//        System.out.println("New Candidate after Crossover: ");
//        displayRoutes(copyParent1.routeTable);
//        System.out.println(copyParent1.fitness);
//        System.out.println("Stop Insertion Validity");

        nextCandidates.add(copyParent1);
        nextCandidates.add(copyParent2);
    }

    private void crossover() {
        nextCandidates = new ArrayList<Candidate>();
        int crossoverPopulationSize = matingPool.size();
        for (int i = 0; i < crossoverPopulationSize; i++) {
            bestRouteCrossover();
        }
        Collections.sort(matingPool);
        for(int i=0;i<matingPool.size();i++) {
            nextCandidates.add(matingPool.get(i));
        }
    }

    private void crossoverPMX() {
        Collections.sort(matingPool);
        //System.out.println("mating pool size : " + matingPool.size());
        Random r = new Random();
        nextCandidates = new ArrayList<Candidate>();
        for (int k = 0; k < populationSize / 2; k++) {

            double probability = r.nextDouble();
            if (probability < crossoverProbability) {

                int candidateSize = matingPool.size();

                int parent1Index = r.nextInt(candidateSize);
                int parent2Index = r.nextInt(candidateSize);
                while (parent1Index == parent2Index) {
                    parent2Index = r.nextInt(candidateSize);
                }

                //        System.out.println("CandidateSize: " + candidateSize);
                //        System.out.println("index1: " + parent1Index);
                //        System.out.println("index2: " + parent2Index);

                Candidate parent1 = matingPool.get(parent1Index);
                Candidate parent2 = matingPool.get(parent2Index);

                Candidate copyParent1 = copyCandidate(parent1);
                Candidate copyParent2 = copyCandidate(parent2);

                int chromosomeSize = matingPool.get(0).chromosome.size();
                int cuttingPoint1 = r.nextInt(chromosomeSize);
                int cuttingPoint2 = r.nextInt(chromosomeSize);

                while (cuttingPoint1 == cuttingPoint2) {
                    cuttingPoint2 = r.nextInt(chromosomeSize);
                }

                if (cuttingPoint1 > cuttingPoint2) {
                    int swap;
                    swap = cuttingPoint1;
                    cuttingPoint1 = cuttingPoint2;
                    cuttingPoint2 = swap;
                }

                ArrayList<Integer> replacement1 = new ArrayList<Integer>();
                ArrayList<Integer> replacement2 = new ArrayList<Integer>();

                for (int i = 0; i < chromosomeSize; i++) {
                    replacement1.add(-1);
                    replacement2.add(-1);
                }

                ArrayList<Integer> offspring1Vector = new ArrayList<Integer>();
                ArrayList<Integer> offspring2Vector = new ArrayList<Integer>();
                for (int i = 0; i < chromosomeSize; i++) {
                    offspring1Vector.add(i);
                    offspring2Vector.add(i);
                }

                for (int i = cuttingPoint1; i <= cuttingPoint2; i++) {
                    offspring1Vector.remove(i);
                    offspring1Vector.add(i, copyParent2.chromosome.get(i));
                    offspring2Vector.remove(i);
                    offspring2Vector.add(i, copyParent1.chromosome.get(i));

                    //Integer element = replacement1.get(copyParent2.chromosome.get(i));
                    int index = copyParent2.chromosome.get(i);
                    replacement1.remove(index);
                    replacement1.add(index, copyParent1.chromosome.get(i));
                    //element = replacement2.get(copyParent1.chromosome.get(i));
                    index = copyParent1.chromosome.get(i);
                    replacement2.remove(index);
                    replacement2.add(index, copyParent2.chromosome.get(i));
                }

                //System.out.println("chromosomeSize: " + chromosomeSize);
                for (int i = 0; i < chromosomeSize; i++) {
                    if ((i >= cuttingPoint1) && (i <= cuttingPoint2)) {
                        continue;
                    }

                    int n1 = copyParent1.chromosome.get(i);
                    int m1 = replacement1.get(n1);

                    int n2 = copyParent2.chromosome.get(i);
                    int m2 = replacement2.get(n2);

//                    int index1 = offspring2Vector.indexOf(n1);
//                    offspring2Vector.add(index1, m1);
//
//                    int index2 = offspring1Vector.indexOf(n2);
//                    offspring1Vector.add(index2, m2);


                    while (m1 != -1) {
                        n1 = m1;
                        m1 = replacement1.get(m1);
                    } // while


                    while (m2 != -1) {
                        n2 = m2;
                        m2 = replacement2.get(m2);
                    } // while

                    Integer element = new Integer(offspring1Vector.get(i));
                    offspring1Vector.remove(element);
                    offspring1Vector.add(i, n1);
                    element = new Integer(offspring2Vector.get(i));
                    offspring2Vector.remove(element);
                    offspring2Vector.add(i, n2);
                }

                //        System.out.println(offspring1Vector);
                //        System.out.println(offspring2Vector);

                Candidate offspring1 = new Candidate();
                Candidate offspring2 = new Candidate();
                offspring1.chromosome = offspring1Vector;
                offspring2.chromosome = offspring2Vector;
//                System.out.println(offspring1);
//                System.out.println(offspring2);

                offspring1.routeTable = generateRoutes(offspring1);
                offspring2.routeTable = generateRoutes(offspring2);
                offspring1.fitness = evaluateFitnessCandidate(offspring1);
                offspring2.fitness = evaluateFitnessCandidate(offspring2);

                //        System.out.println("offspring1 route: ");
                //        displayRoutes(offspring1.routeTable);
                //        System.out.println("fitness: " + offspring1.fitness);
                //
                //        System.out.println("offspring2 route: ");
                //        displayRoutes(offspring2.routeTable);
                //        System.out.println("fitness: " + offspring2.fitness);
                nextCandidates.add(offspring1);
                nextCandidates.add(offspring2);
            } else {
                nextCandidates.add(matingPool.get(k % 10));
            }
        }

        int tmpSize = populationSize - nextCandidates.size();
        //System.out.println("tmpsize: " + tmpSize);
        for (int i = 0; i < tmpSize; i++) {
            nextCandidates.add(matingPool.get(i));
        }
    }

    private int checkStoresAll(ArrayList<Route> tmp) {
        int result = 0;
        for (Route r : tmp) {
            result += r.route.size() - 1;
        }
        return result + 1;
    }

    private ArrayList<Route> removeSelectedElements(Route temp, ArrayList<Route> alrouteParent) {
        ArrayList<Route> temporary = new ArrayList<Route>();
        for (Route tmp : alrouteParent) {
            for (int i : temp.route) {
                if (i == 0) {
                    continue;
                }
                tmp.route.remove(new Integer(i));
            }
            if (!tmp.route.isEmpty()) {
                temporary.add(tmp);
            }
        }
        return temporary;
    }

    private Candidate copyCandidate(Candidate tmp) {
        Candidate tmpCopy = new Candidate();
        tmpCopy.fitness = tmp.fitness;
        tmpCopy.rank = tmp.rank;
        for (int i : tmp.chromosome) {
            tmpCopy.chromosome.add(new Integer(i));
        }
        for (Route tmpRoute : tmp.routeTable) {
            Route copyRoute = new Route();
            for (int i : tmpRoute.route) {
                copyRoute.route.add(new Integer(i));
            }
            tmpCopy.routeTable.add(copyRoute);
        }

        return tmpCopy;
    }

    private boolean checkInsertionValidity(Route tmp) {
        if (tmp.route.size() > maxStops) {
            return false;
        }

        double currentDistance = DCStoreMatrix[0][tmp.route.get(0)];
        int currentDemand = stores.get(tmp.route.get(0)).demand;
        for (int i = 1; i < tmp.route.size(); i++) {
            currentDistance += DCStoreMatrix[tmp.route.get(i - 1)][tmp.route.get(i)];
            currentDemand += stores.get(tmp.route.get(i)).demand;
        }

        if (currentDemand > maxDemand || currentDistance > maxDistanceTravelled / 2) {
            return false;
        }
        return true;
    }

    
    private void writeToFile() {
        try {
            
            FileInputStream finbest = new FileInputStream("bestsolutions.kart");
            ObjectInputStream oisbest = new ObjectInputStream(finbest);
            
            FileOutputStream fout = new FileOutputStream("solutions.kart");
            FileOutputStream foutstores = new FileOutputStream("stores.kart");
            ObjectOutputStream oos = new ObjectOutputStream(fout);
            ObjectOutputStream oosstores = new ObjectOutputStream(foutstores);
            
            ArrayList<Candidate> bestCandidates = new ArrayList<>();
            
            int i=0;
            for (Candidate c : currentCandidates) {
                i++;
                oos.writeObject(c);
                bestCandidates.add(c);
                if (i == 10) {
                    break;
                } 
            }
            
            for (Store s : stores) {
                oosstores.writeObject(s);
            }
            
            // Read Best Candidates
            int j=0;
            while(true) {
                j++;
                Candidate tmpBestCandidate = (Candidate) oisbest.readObject();
                bestCandidates.add(tmpBestCandidate);
                if(j==10) {
                    break;
                }
            }
            
            Collections.sort(bestCandidates);
            
            FileOutputStream foutbest = new FileOutputStream("bestsolutions.kart");
            ObjectOutputStream oosbest = new ObjectOutputStream(foutbest);
            int k=0;
            for (Candidate c : bestCandidates) {
                k++;
                oosbest.writeObject(c);
                if (k == 10) {
                    break;
                } 
            }
            
        } catch (IOException | ClassNotFoundException e) {
        }
    }
    
    
    // Methods to generate a string for saving the result in pdf.
   

}


// Class Adjust Factors for setting the variables of genetic operations
class AdjustFactors {
    /*
     * Used to set the Genetic operator values as fetched from the user.
     */
    GroceryKart g;
    
    int selectionPercent;
    double crossoverProbability;
    double mutationProbability;
    
    AdjustFactors(int selectionPercent, double crossoverProbibility, double mutationProbability) {
        
        g = new GroceryKart();
 
        this.selectionPercent = selectionPercent;
        this.crossoverProbability = crossoverProbibility;
        this.mutationProbability = mutationProbability;
    }
    
}
